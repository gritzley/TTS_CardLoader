-- lua does not support regex, as regex is larger than lua itself. It has its own simpler (and uglier) pattern matcher.
-- it even supports capture groups. just ignore how ugly it looks
SET_ID_PATTERN = "(%w%w%w*)"
COLLECTOR_ID_PATTERN = "(%d%d?%d?)"
CARDNAME_PATTERN = "([%w%s%p'\"%+%_/]+)"
SIMPLE_PATTERN = "(%d+)%s"..CARDNAME_PATTERN
MTGA_STRING_PATTERN = SIMPLE_PATTERN.."%("..SET_ID_PATTERN.."%)%s"
MTGA_STRING_PATTERN_EXACT = MTGA_STRING_PATTERN..COLLECTOR_ID_PATTERN
MTGO_STRING_PATTERN = SIMPLE_PATTERN.."%s%["..SET_ID_PATTERN.."%]"
MTGO_STRING_PATTERN_EXACT = SIMPLE_PATTERN.."%s<"..COLLECTOR_ID_PATTERN..">%s%["..SET_ID_PATTERN.."%]"

MAINDECK_POSITION = {0, 1, 0}
SIDEBOARD_POSITION = {3, 1, 0}
COMMANDER_POSITION = {0, 1, 3}
COMPANION_POSITION = {3, 1, 3}

function createAPISearchData(decklist)
    local data = {}

    local target = MAINDECK_POSITION
    local targetLookup = {
        Deck = MAINDECK_POSITION,
        Sideboard = SIDEBOARD_POSITION,
        Commander = COMMANDER_POSITION,
        Companion = COMPANION_POSITION
    }
    local Companion = nil

    for line in magiclines(decklist) do

        local card = {}
        local skip = false

        card.target = target

        if line:match(MTGO_STRING_PATTERN_EXACT) then
            -- e.G. 3 Island <251> [THB]
            -- the additional data between the <> brackets can contain a collector_number zo get the exact land, as lands get several versions per set
            _, _, card.amount, _ , card.collector_number, card.set = line:find(MTGO_STRING_PATTERN_EXACT)

        elseif line:match(MTGO_STRING_PATTERN) then
            -- e.G. 4 Archmage's Charm [MH1] (F)
            -- This is just straight up amount, name and set. The information in round brackets at the end can be ignored (F is for foil)
            _, _, card.amount, card.name, card.set = line:find(MTGO_STRING_PATTERN)

        elseif line:match(MTGA_STRING_PATTERN_EXACT) then
            -- e.G. 4 Bard Class (AFR) 217
            -- MTGA uses a slightly different format so we need to account for that.
            -- as MTGA always provides a collector_number, we always use that and ignore the name.
            _, _, card.amount, _, card.set, card.collector_number = line:find(MTGA_STRING_PATTERN_EXACT)

            -- MTGA puts the companion in the sideboard and in a special slot so we have to skip the slot in the sideboard, if the companion is already set.
            -- This is by no means perfect but should cover lists exported fron MTGA
            if target == COMPANION_POSITION then
                Companion = line
            elseif
                Companion == line then skip = true
            end

        elseif line:match(MTGA_STRING_PATTERN) then
            -- e.G. 1 Mystic Remora (ICE)
            -- Some sites export in the MTGA format but without the collectors id...
            _, _, card.amount, card.name, card.set = line:find(MTGA_STRING_PATTERN)

            -- See above
            if target == COMPANION_POSITION then
                Companion = line
            elseif
                Companion == line then skip = true
            end

        elseif line:match(SIMPLE_PATTERN) then
            -- e.G. 4 Forest
            -- if you don't care about printings, this can easily spawn stuff
            _, _, card.amount, card.name = line:find(SIMPLE_PATTERN)

        else
            -- if the line specifies a position, we take it. if not we default to the sideboard
            -- this is because a lot of formats simply use an empty line to signify the sideboard
            target = targetLookup[line:gsub("%s+", "")] or SIDEBOARD_POSITION
            skip = true
        end

        if skip then
            skip = false
        else
            -- Names of split cards like "Fire//Ice" mess up the scryfall search.
            -- Luckily, the name of each part of the card must be unique aswell, so searching for just "Fire" will yield the same card.
            if card.name ~= nil then card.name = card.name:gsub("/.*","") end

            -- and we have to do some stuff with the set aswell, which i have bundled
            if card.set ~= nil then card.set = ammendSetName(card.set) end

            table.insert(data, card)
        end
    end

    return data
end

function ammendSetName(set)
    set = string.lower(set)
    -- MTGA uses DAR as a code for DOM. This is likely because Dominaria was the first set on arena and DAR might signify "Dominaria Arena"
    -- Some sites use DAR aswell so this might need to
    if set == "dar" then set = "dom" end
    -- some sites use [1E, 2E ...] instead of [1ED, 2ED, ...] but scryfall doesn't liek that so we add the d
    if set ~= nil and set:match("%de$") then
        set = set.."d"
    end

    return set
end
