CARD_BACK_URL = "https://static.wikia.nocookie.net/mtgsalvation_gamepedia/images/f/f8/Magic_card_back.jpg/revision/latest?cb=20140813141013"
SCRYFALL_BASE_URL = "https://api.scryfall.com/"
-- lua does not support regex, as regex is larger than lua itself. It has its own simpler (and uglier) pattern matcher.
-- it even supports capture groups. just ignore how ugly it looks
SET_ID_PATTERN = "(%w%w%w*)"
COLLECTOR_ID_PATTERN = "(%d%d?%d?)"
CARDNAME_PATTERN = "([%w%s%p'\"%+%_/]+)"
MTGA_STRING_PATTERN = "(%d+).*%("..SET_ID_PATTERN.."%)%s"..COLLECTOR_ID_PATTERN
STRING_PATTERN_WITH_ADDITIONAL_DATA = "(%d+)%s"..CARDNAME_PATTERN.."%s<(.+)>%s%["..SET_ID_PATTERN.."%]"
STRING_PATTERN = "(%d+)%s"..CARDNAME_PATTERN.."%s%["..SET_ID_PATTERN.."%]"

MAINDECK_POSITION = {-1, 1, -1}
SIDEBOARD_POSITION = {1, 1, -1}
COMMANDER_POSITION = {1, 1, 1}
COMPANION_POSITION = {-1, 1, 1}

SCRYFALL_DATA_MAX_BATCH_SIZE = 75

COMMAND_PATTERN = "^%$(%w+)%s?(.*)"
COMMAND_LOOKUP = {
    ["import"] = function (_, player)
        UI.setAttribute("popup", "active", "true")
        UI.setAttribute("popup", "visibility", player.color)
    end
}

function onLoad()
    UI.setXml([[
        <VerticalLayout
        id="popup"
        width="300"
        height="800"
        active="false"
        childAlignment="UpperRight"
        childForceExpandWidth="false"
        childForceExpandHeight="false">
            <Button
                onClick="closePopup"
                preferredWidth="30"
                preferredHeight="30">
                X
            </Button>
            <InputField
                id="decklist_input"
                preferredWidth="300"
                preferredHeight="700"
                onValueChanged="updatePopupValue"
                lineType="MultiLineNewLine">
            </InputField>
            <Button
                onClick="importDeckFromPopup"
                preferredWidth="300"
                preferredHeight="40">
                Import
            </Button>
        </VerticalLayout>
    ]])
end

function closePopup()
    UI.setAttribute("popup", "active", "false")
end

function importDeckFromPopup()
    local data = createAPISearchData(POPUP_VALUE)
    createCardsFromData(data)
    closePopup()
end

function updatePopupValue(obj, value)
    POPUP_VALUE = value
end

function onChat(message, player)
    _, _, command, params = message:find(COMMAND_PATTERN)
    if command ~= nil then
        if COMMAND_LOOKUP[command] ~= nil then
            COMMAND_LOOKUP[command](params, player)
        else
            print(command.." is not a command")
        end
        return false
    end
end

function createAPISearchData(decklist)
    local target = MAINDECK_POSITION
    local targetLookup = {
        Deck = MAINDECK_POSITION,
        Sideboard = SIDEBOARD_POSITION,
        Commander = COMMANDER_POSITION,
        Companion = COMPANION_POSITION
    }
    local data = {}
    local Companion = nil

    for line in magiclines(decklist) do

        local card = {}
        local skip = false

        card.target = target

        if line:match(STRING_PATTERN_WITH_ADDITIONAL_DATA) then
            card = decodeMTGOstring_additionalData(line)

        elseif line:match(STRING_PATTERN) then
            card = decodeMTGOstring(line)

        elseif line:match(MTGA_STRING_PATTERN) then
            card, skip, Companion = decodeMTGAstring(line, target == Companion, Companion)

        else
            -- if the line specifies a position, we take it. if not we default to the sideboard
            -- this is because a lot of formats simply use an empty line to signify the sideboard
            target = targetLookup[line:gsub("%s+", "")] or SIDEBOARD_POSITION
            skip = true
        end

        if skip then
            skip = false
        else
            card.set = ammendSetName(card.set)
            table.insert(data, card)
        end
    end

    return data
end

-- e.G. 4 Archmage's Charm [MH1] (F)
-- This is just straight up amount, name and set. The information in round brackets at the end can be ignored (F is for foil)
function decodeMTGOstring(line)
    local card = {}
    local _, _, amount, name, set = line:find(STRING_PATTERN)

    card.amount = amount
    card.name = name:gsub("/.*","")
    card.set = string.lower(set)

    return card
end

-- e.G. 3 Island <251> [THB]
-- the additional data between the <> brackets can contain a collector_number in which case we prefer to use that over the name as it is
-- more accurate when fetching lands
function decodeMTGOstring_additionalData(line)
    local card = {}
    local _, _, amount, name, additionalData, set = line:find(STRING_PATTERN_WITH_ADDITIONAL_DATA)

    card.amount = amount

    if (additionalData:match(COLLECTOR_ID_PATTERN)) then
        card.set = string.lower(set)
        card.collector_number = additionalData
    else
        card.name = name:gsub("/.*","")
        card.set = string.lower(set)
    end

    return card
end

-- e.G. 4 Bard Class (AFR) 217
-- MTGA uses a slightly different format so we need to account for that.
-- as MTGA always provides a collector_number, we always use that and ignore the name.
function decodeMTGAstring(line, isCompanion, companion)
    -- MTGA puts companions into the sideboard and a special companion slot.
    -- If we find the Companion in the sideboard we skip it.
    if (isCOmpanion) then
        companion = line
    elseif (companion == line) then
        skip = true
    end

    local card = {}
    local _, _, amount, setID, collectorsID = line:find(MTGA_STRING_PATTERN)

    card.amount = amount
    card.set = setID
    card.collector_number = collectorsID

    return card, skip, companion
end

function ammendSetName(set)
    -- MTGA uses DAR as a code for DOM. This is likely because Dominaria was the first set on arena and DAR might signify "Dominaria Arena"
    -- Some sites use DAR aswell so this might need to
    if set == "DAR" then set = "DOM" end
    -- some sites use [1E, 2E ...] instead of [1ED, 2ED, ...] but scryfall doesn't liek that so we add the D
    if set ~= nil and set:match("%de") then
        set = set.."d"
    end

    return set
end

function createCardsFromData(data)
    local body = JSON.encode({
        identifiers = data
    })

    local headers = {
        ["Content-Type"] = "application/json"
    }
    WebRequest.custom(SCRYFALL_BASE_URL.."/cards/collection", "POST", true, body, headers, function(request)

        -- standard error handling
        if request.is_error then
            print ("Request Failed")
            return
        end

        -- dealing with non-json data
        local contentType = request.getResponseHeader("Content-Type") or ""
        if contentType ~= "application/json" and not contentType:match("^application/json;") then
            print("Unexpected response from Scryfall.")
            return
        end

        local cards = JSON.decode(request.text).data

        for i, value in ipairs(cards) do
            for j=1, data[i].amount do createCard(value, data[i].target) end
        end
    end)
end

function createCard(data, target)
    local cardData = {
        type = "CardCustom",
        positon = target,
        rotation = {0, 180, 180}
    }
    local card = spawnObject(cardData)

    if data.image_uris ~= nil then
        card.setCustomObject({
            face = data.image_uris.large,
            back = CARD_BACK_URL
        })
    else
        card.setCustomObject({
            face = data.card_faces[1].image_uris.large,
            back = CARD_BACK_URL
        })

    end

    card.setName(data.name)
end

function magiclines(s)
    if s:sub(-1)~="\n" then s=s.."\n" end
    return s:gmatch("(.-)\n")
end
